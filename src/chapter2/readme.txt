
本章思路：数据在计算机中的存储-》如何在计算机中操作数据-》如何实现指令（C语言形式翻译）。最后以现代处理机为例。

1.
编码方式：
原码，反码，补码。
数字表示：
无符号整数，一般使用原码表示
有符号整数：使用补码表示
浮点数：使用以2为基数的科学计数法表示
整数表示时，范围小，精度高
浮点数表示时，范围大，近似

2.
机器字长
指令字长
存储字长

存储字长：一般就是MDR寄存器的位数。指一个存储单元存储的数据的位数。
机器字长：一般和寄存器的位数有关，一次可以处理的数据位数。像32位机器，64位机器。越长一次处理的数据越多，同时数据表示越精确。
指令字长：指的是一条指令的位数。
三者之间没有必然联系。
一般便于处理的话，三种字长一样长。
三种字长一般都是字节的整数倍。

3.
在交换两个数值的时候。可以借助按位 ^（异或） 运算来交换
x = x ^ y;
y = x ^ y;
x = x ^ y;
原理很简单：x ^ x = 0;
4.
算术右移添加符号位。逻辑右移加0。
要想取二进制的后面m位，则对pow(2，m）取余。
要想去掉后面m位，则可以除以pow（2，m）。

5、
有符号数扩充添符号位，无符号数扩充添0。

6.
小心无符号与有符号数混用时带来的程序bug。
因为在程序中，如果一个计算式中有一个无符号数存在，编译器就会隐式的将所有的都转换为无符号数。
比如：x - y >= 0式子中，
如果x是无符号数，y是有符号数，此时该等式恒成立。。。
！！！Remember。It's dangerous。

7.
四则运算溢出检测
w位。
加法： s = x + y。
无符号数：如果s < x(y) ，则说明加法溢出。
有符号数：分为正溢出和负溢出。如果s >= pow(2,w-1)，则正溢出；
如果s < -pow(2,w-1)，则负溢出。
规则的表示：当且仅当x>0且y>0且s<=0时，结果上溢出。
当且仅当x<0、y<0且s>0时，结果下溢出。
正溢出的时候结果值少了pow(2,w)，负溢出的时候结果值多出了pow(2,w)。
正溢出的时候处理和无符号溢出处理无二致，减去pow(2,w)。
负溢出的时候则加上pow(2,w)。

8.
补码表示形式下，x的非不一定是-x，而是有两种情况：
如果x == pow(2,w-1)，那么x的逆元就是其本身（可以根据逆元定义得出：元素本身与其逆元运算结果为单位元）。
否则，x的逆元就是-x。

9.
补运算和非运算有联系：
-x = ~x+1。
即x的非（反） 等于 x的补加上1。这个结论很重要！！！
可以验证一下：
以w=4，为例：
   x        ~x    ~x+1       -x
 0101(5)   1010   1011(-5)   -5
 0111(7)   1000   1001(-7)   -7
 1100(-4)  0011   0100(4)     4
 0000(0)   1111   0000(0)     0
 1000(-8)  0111   1000(-8)   -8

可以看出，当x == 补码最小值（这里是-8）时，x的非与x同等。
否则为-x。
本书中的这种~（补）运算，就相当于以前学过的反码运算，-（非）运算，就相当于求补码。


10.
计算机中的补码运算，首先是将运算数换算成无符号数，在进行无符号数运算，最后将无符号数变换成有符号数。


11.
p109
除法运算非常费时，同时，当除不断时，如果是同号相除，则结果向下取整；如果是异号相除，则结果向上取整，如-2.1会取整为-2、
所以无符号数除法很简单，直接向下取整即可。
有符号数相除时，同号相除没有问题，异号相除的时候，
运用无符号数相似的原理计算、移位时，虽然总体来看没有差别，但是在舍入的时候，
不会是向上取整，而是保持同号相除时的向下取整。
要解决这个问题，需要在右移位之前对x加上一个“偏置”量：pow(2，k）-1。
最后就是：（(x+pow(2,k)-1)>>k。这样之后就会向零取值（向上取整）。
其中x是要除的数，k是移位位数。
原理：
前提：y>0
向上取整（x/y) = 向下取整（（x+y-1)/y)。

如，当x = -30，y = 4时，
向上取整（x/y) = 向上取整（-7.5） = -7
向下取整（（x+y-1)/y) = 向下取整((-30+4-1)/4) = 向下取整(-27/4） = 向下取整（-6.75） = -7
-7 = -7
ok.

12.
注意习题2.44！！！


13.
计算机中浮点数遵循IEEE规则存放，即将一个浮点数规则化为标准形式，以科学计数法为准。
存储的时候将32位（举例）分为 符号位 阶码位 尾数位，分别占据1位、8位、23位。
并且默认规则化后的小数点之前有一个1，所以如果真实的尾数是1.10101。
存储的时候只需要存储为 10101 即可。


浮点数特点：范围大，精度小，越靠近0数的密度越大，越往外越分散。
如果阶码全为0或者全为1，此时不是规格化数。
当阶码全为0而且尾数全为0，表示为0,；阶码全为1，尾数全为0，表示无穷大；
阶码全为1，尾数不全为0，表示NAN。

规格化时与非规格化时的换算规则不一样：
（符号位1位，阶码n位，尾数m位）
规格化时，
E = e - (pow（2，n-1) - 1)。其中e根据二进制串读取。
M = f + 1。 同样f也是根据二进制串对应部分读取。
真实的值 = M*pow(2,E)。
非规格化时，
E = 1 - (pow（2，n-1） - 1)。
M = f。

14.
浮点数的舍入。
一般采用 向4偶数舍入 的方法。
（使用0表示偶数，1表示奇数）
具体规则如下：
使用例子说明。
x = 0.01011
此时要保留三位小数，
因为此时第三位是0，已经是偶数，所以直接丢掉后面两位。
x = 0.01111
此时还是要保留三位小数，
此时第三位小数是1，为奇数，所以看第四位。如果第四位是1，则向前进一位；否则直接丢掉，不用管第三位是否是偶数（0）。


再使用更详细的：
要求：保留三位小数。
①对于1.0011001，舍入后结果为 1.010。去掉后四位，并且加上0.001，因为此时第三位是奇数，而且第四位是1。
②对于1.0010111，舍入后结果为1.001。去掉后四位，尽管第三位是奇数，但是第四位并不是1，所以直接丢掉。
③对于1.0011000，舍入后结果为1.010.去掉后四位，加上0.01。原因同例①。


15.
这是一条note！！！
在换算的时候，一定不能拿起笔就做。一定要先看看，所给的二进制串是否是规格化的，再根据不同的形式，选取不同的换算规则。

16.
注意整数使用浮点数的形式来表示后，两种方式的二进制串中，尾数部分和整数二进制串除最高非零位以外的位重叠。
这也是整数转浮点数不一定会保留精度的原因。
一般而言，如果尾数部分占用n位，此时最多去表示一个值为pow（2，n+1）的整数。
当一个整数值为pow（2，n+1) + 1时，如果转成浮点表示，则会被截断。
原因在于尾数部分与整数表示的二进制串无法完成重叠，因此整数转浮点的时候就会截断整数二进制串的低位。

17.
在非规格化的运算公式中，E = 1 - bias。
这里的1会使得非规格化数与规格化之间平滑衔接，因此，如果将浮点数二进制串解释为无符号整数，则结果会按照升序排列。





