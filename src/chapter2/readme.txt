
本章思路：数据在计算机中的存储-》如何在计算机中操作数据-》如何实现指令（C语言形式翻译）。最后以现代处理机为例。

1.
编码方式：
原码，反码，补码。
数字表示：
无符号整数，一般使用原码表示
有符号整数：使用补码表示
浮点数：使用以2为基数的科学计数法表示
整数表示时，范围小，精度高
浮点数表示时，范围大，近似

2.
机器字长
指令字长
存储字长

存储字长：一般就是MDR寄存器的位数。指一个存储单元存储的数据的位数。
机器字长：一般和寄存器的位数有关，一次可以处理的数据位数。像32位机器，64位机器。越长一次处理的数据越多，同时数据表示越精确。
指令字长：指的是一条指令的位数。
三者之间没有必然联系。
一般便于处理的话，三种字长一样长。
三种字长一般都是字节的整数倍。

3.
在交换两个数值的时候。可以借助按位 ^（异或） 运算来交换
x = x ^ y;
y = x ^ y;
x = x ^ y;
原理很简单：x ^ x = 0;
4.
算术右移添加符号位。逻辑右移加0。
要想取二进制的后面m位，则对pow(2，m）取余。
要想去掉后面m位，则可以除以pow（2，m）。

5、
有符号数扩充添符号位，无符号数扩充添0。

6.
小心无符号与有符号数混用时带来的程序bug。
因为在程序中，如果一个计算式中有一个无符号数存在，编译器就会隐式的将所有的都转换为无符号数。
比如：x - y >= 0式子中，
如果x是无符号数，y是有符号数，此时该等式恒成立。。。
！！！Remember。It's dangerous。

7.
四则运算溢出检测
w位。
加法： s = x + y。
无符号数：如果s < x(y) ，则说明加法溢出。
有符号数：分为正溢出和负溢出。如果s >= pow(2,w-1)，则正溢出；
如果s < -pow(2,w-1)，则负溢出。
规则的表示：当且仅当x>0且y>0且s<=0时，结果上溢出。
当且仅当x<0、y<0且s>0时，结果下溢出。
正溢出的时候结果值少了pow(2,w)，负溢出的时候结果值多出了pow(2,w)。
正溢出的时候处理和无符号溢出处理无二致，减去pow(2,w)。
负溢出的时候则加上pow(2,w)。

8.
补码表示形式下，x的非不一定是-x，而是有两种情况：
如果x == pow(2,w-1)，那么x的逆元就是其本身（可以根据逆元定义得出：元素本身与其逆元运算结果为单位元）。
否则，x的逆元就是-x。

9.
补运算和非运算有联系：
-x = ~x+1。
即x的非（反） 等于 x的补加上1。这个结论很重要！！！
可以验证一下：
以w=4，为例：
   x        ~x    ~x+1       -x
 0101(5)   1010   1011(-5)   -5
 0111(7)   1000   1001(-7)   -7
 1100(-4)  0011   0100(4)     4
 0000(0)   1111   0000(0)     0
 1000(-8)  0111   1000(-8)   -8

可以看出，当x == 补码最小值（这里是-8）时，x的非与x同等。
否则为-x。
本书中的这种~（补）运算，就相当于以前学过的反码运算，-（非）运算，就相当于求补码。


10.
计算机中的补码运算，首先是将运算数换算成无符号数，在进行无符号数运算，最后将无符号数变换成有符号数。


11.
p109
除法运算非常费时，同时，当除不断时，如果是同号相除，则结果向下取整；如果是异号相除，则结果向上取整，如-2.1会取整为-2、
所以无符号数除法很简单，直接向下取整即可。
有符号数相除时，同号相除没有问题，异号相除的时候，
运用无符号数相似的原理计算、移位时，虽然总体来看没有差别，但是在舍入的时候，
不会是向上取整，而是保持同号相除时的向下取整。
要解决这个问题，需要在右移位之前对x加上一个“偏置”量：pow(2，k）-1。
最后就是：（(x+pow(2,k)-1)>>k。这样之后就会向零取值（向上取整）。
其中x是要除的数，k是移位位数。
原理：
前提：y>0
向上取整（x/y) = 向下取整（（x+y-1)/y)。

如，当x = -30，y = 4时，
向上取整（x/y) = 向上取整（-7.5） = -7
向下取整（（x+y-1)/y) = 向下取整((-30+4-1)/4) = 向下取整(-27/4） = 向下取整（-6.75） = -7
-7 = -7
ok.

12.
注意习题2.44！！！


13.







